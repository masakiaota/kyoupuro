# https://atcoder.jp/contests/abc155/tasks/abc155_e
# DPで解き直してみる
# アイデアとしては以下
# F(n)をn円使ったときに使う紙幣の最小と定義
# 例えばF(36)→8,(サンプルの通り)、F(4)→4、F(6)→5
# F(23456)を考える
# F(23456)=min(F(2345)+6, F(2346)+4) となる
# ∵6をそのまま払うなら、桁上りは必要ないので2345を払う最小F(2345)を足せば良い。
# お釣り狙いならばとりあえず、10 - 6のお釣りの分をカウント。そして上位桁で多く払う分2346の最小F(2346)を足せば良い。

# ナイーブな実装

'''
def F(n: int):
    if n < 5:
        # 終了条件
        return n
    a, b = divmod(n, 10)
    ret = min(F(a) + b, F(a + 1) + (10 - b))
    # print(n, ret)
    return ret


print(F(int(input())))
'''
# しかしこれには不適切な実装が含まれている
# 1、再帰の深さが最大100000になる。再帰メモ化でもハッシュの衝突が起きたりして遅くなる可能性がある
# 2、int型を前提にした実装なので、10^100000の大きさの数字を扱おうとするとかなり遅くなる。
# よって上記の再帰関数をdpの形で書き直し、且つ文字列で扱える処理に変更する必要がある。


N = input()
# Nの先頭に0がついているとみたてて
dp0 = 0  # 桁上がりしない
dp1 = 1  # 桁上りするときに必要な紙幣の枚数

for n in N:
    n = int(n)
    dp0_new = min(dp0 + n, dp1 + (10 - n))
    n = n + 1
    dp1_new = min(dp0 + n, dp1 + (10 - n))
    dp0, dp1 = dp0_new, dp1_new

print(dp0)
