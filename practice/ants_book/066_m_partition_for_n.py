# nのm分割数というらしい
# n個の区別できない品物をmグループ以下に分割する分け方の総数
#

n = 4
m = 3

'''
dp[i][j] ... jのi分割の総数
更新則
dp[i][j] = dp[i-1][j] + dp[i][j-i]
∵ jのi分割の定式化 →sum_{k=1..i} a_k = j
a_k=0がある時、これはi-1分割と定式化が同じになる→総数は等しい (=0は常にある)
a_k>0のとき、すべての要素(i個)から1を引くことができる。これはj-iのi分割の総数と等しくなる。
(ただしj-i>=0)
初期条件
dp[0][0]=1 #0の0分割は1通りと定義すると都合が良い(表を書き出してみるとわかりやすい)
'''

dp = [[0] * (n + 1) for _ in range(m + 1)]
dp[0][0] = 1

for i in range(1, m + 1):
    for j in range(n + 1):
        dp[i][j] = dp[i - 1][j] + (dp[i][j - i] if j - i >= 0 else 0)

print(dp[m][n])

print(*dp, sep='\n')
'''
[1, 0, 0, 0, 0]
[1, 1, 1, 1, 1]
[1, 1, 2, 2, 3]
[1, 1, 2, 3, 4]
この出力を見ればわかるように本来初期条件はdp[1][j]=1である。∵1分割はどんな数字でも必ず1通りになるから
しかし(0,0)に1を埋めておくと更新のときに全部それはやってくれるという仕組み
'''
